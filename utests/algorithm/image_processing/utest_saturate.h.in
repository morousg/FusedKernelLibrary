/* Copyright 2025 Oscar Amoros Huguet
   Copyright 2025 Grup Mediapro S.L.U

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. */

#include <fused_kernel/algorithms/image_processing/saturate.h>
#include <fused_kernel/algorithms/basic_ops/cast.h>
#include <fused_kernel/core/utils/cuda_vector_utils.h>
#include <fused_kernel/core/utils/type_lists.h>
#include <fused_kernel/core/utils/type_to_string.h>
#include <fused_kernel/core/utils/vlimits.h>
#include <tests/operation_test_utils.h>
#ifdef WIN32
#include "utest_saturate_@FUNDAMENTAL_TYPE@_export.h"
#endif

#if defined(__GNUC__) && !defined(_WIN32)
#define  EXPORT_FN_@FUNDAMENTAL_TYPE_UPPER@  __attribute__((visibility("default")))
#else
#define  EXPORT_FN_@FUNDAMENTAL_TYPE_UPPER@ 
#endif

inline std::string niceType@FUNDAMENTAL_TYPE@(const std::string& input) {
    // Map "unsigned type" to specific type names
    static const std::unordered_map<std::string, std::string> unsignedTypeMap = {
        {"unsigned char", "uchar"},
        {"unsigned short", "ushort"},
        {"unsigned int", "uint"},
        {"unsigned long", "ulong"},
        {"unsigned longlong", "ulonglong"},
        {"__int64", "longlong"},
        {"unsigned __int64", "ulonglong"}
    };

    // Check if the input matches any key in the map
    auto it = unsignedTypeMap.find(input);
    if (it != unsignedTypeMap.end()) {
        return it->second; // Return the mapped type name
    }
    return input;
}

template <typename InputType, typename OutputType>
constexpr OutputType expectedMinValue@FUNDAMENTAL_TYPE@() {
    if constexpr (cxp::cmp_less_equal(fk::minValue<fk::VBase<InputType>>, fk::minValue<fk::VBase<OutputType>>)) {
        return fk::minValue<OutputType>;
    } else {
        return fk::Cast<InputType, OutputType>::exec(fk::minValue<InputType>);
    }
}

template <typename T>
constexpr T halfPositiveRange@FUNDAMENTAL_TYPE@() {
    return fk::make_set<T>(fk::maxValue<fk::VBase<T>> / 2);
}

template <typename OutputType, typename InputType>
constexpr OutputType expectedPositiveValue@FUNDAMENTAL_TYPE@(const InputType& input) {
    if (cxp::cmp_greater(fk::VectorAt<0>(input), fk::maxValue<fk::VBase<OutputType>>)) {
        return fk::maxValue<OutputType>;
    } else {
        return fk::Cast<InputType, OutputType>::exec(input);
    }
}

template <typename InputType, typename OutputType>
void addOneTest@FUNDAMENTAL_TYPE@() {
    // minValue<Input> <= minValue<Output> -> output{ fk::minValue<Output>, ... }
    // minValue<Input> > minValue<Output> -> output{ fk::Cast<Input, Output>::exec(fk::minValue<Input>), ... }
    constexpr OutputType expectedMinVal = expectedMinValue@FUNDAMENTAL_TYPE@<InputType, OutputType>();

    // maxValue<Input> < maxValue<Output> -> output{ ... , fk::Cast<Input, Output>::exec(fk::maxValue<Input>) }
    // maxValue<Input> >= maxValue<Output> -> output{ ... , fk::maxValue<Output> }
    constexpr OutputType expectedMaxVal = expectedPositiveValue@FUNDAMENTAL_TYPE@<OutputType>(fk::maxValue<InputType>);

    // halfPositiveRange<InputType>() < maxValue<Output> -> output{ ... , fk::Cast<Input, Output>::exec(fk::maxValue<Input>) }
    // halfPositiveRange<InputType>() >= maxValue<Output> -> output{ ... , fk::maxValue<Output> }
    constexpr OutputType expectedHalfMaxValue = expectedPositiveValue@FUNDAMENTAL_TYPE@<OutputType>(halfPositiveRange@FUNDAMENTAL_TYPE@<InputType>());

     constexpr std::array<InputType, 3> inputVals{ fk::minValue<InputType>, halfPositiveRange@FUNDAMENTAL_TYPE@<InputType>(), fk::maxValue<InputType> };
    constexpr std::array<OutputType, 3> outputVals{ expectedMinVal, expectedHalfMaxValue, expectedMaxVal};
    
    TestCaseBuilder<fk::SaturateCast<InputType, OutputType>>::addTest(testCases, inputVals, outputVals);
}

template <typename BaseInput, typename BaseOutput>
void addOneTestAllChannels@FUNDAMENTAL_TYPE@() {
    // Base Type
    addOneTest@FUNDAMENTAL_TYPE@<BaseInput, BaseOutput>();

    // Vector of 1
    using Input1 = typename fk::VectorType<BaseInput, 1>::type_v;
    using Output1 = typename fk::VectorType<BaseOutput, 1>::type_v;
    addOneTest@FUNDAMENTAL_TYPE@<Input1, Output1>();

    // Vector of 2
    using Input2 = fk::VectorType_t<BaseInput, 2>;
    using Output2 = fk::VectorType_t<BaseOutput, 2>;
    addOneTest@FUNDAMENTAL_TYPE@<Input2, Output2>();

    // Vector of 3
    using Input3 = fk::VectorType_t<BaseInput, 3>;
    using Output3 = fk::VectorType_t<BaseOutput, 3>;
    addOneTest@FUNDAMENTAL_TYPE@<Input3, Output3>();

    // Vector of 4
    using Input4 = fk::VectorType_t<BaseInput, 4>;
    using Output4 = fk::VectorType_t<BaseOutput, 4>;
    addOneTest@FUNDAMENTAL_TYPE@<Input4, Output4>();
}

template <typename TypeList_, typename Type, size_t... Idx>
void addAllTestsFor_helper@FUNDAMENTAL_TYPE@(const std::index_sequence<Idx...>&) {
    static_assert(fk::validCUDAVec<Type> || std::is_fundamental_v<Type>, "Type must be either a cuda vector or a fundamental type.");
    static_assert(fk::isTypeList<TypeList_>, "TypeList_ must be a valid TypeList.");
    // For each type in TypeList_, add tests with Type
    (addOneTestAllChannels@FUNDAMENTAL_TYPE@<fk::TypeAt_t<Idx, TypeList_>, Type>(), ...);
}

template <typename TypeList_, size_t... Idx>
void addAllTestsFor@FUNDAMENTAL_TYPE@(const std::index_sequence<Idx...>&) {
    // For each type in TypeList_, add tests with each type in TypeList_
    (addAllTestsFor_helper@FUNDAMENTAL_TYPE@<TypeList_, fk::TypeAt_t<Idx, TypeList_>>(std::make_index_sequence<TypeList_::size>{}), ...);
}
 
template <typename OutputTypeList, typename InputType, size_t... Idx>
void addAllOutputTestsForInput@FUNDAMENTAL_TYPE@(const std::index_sequence<Idx...>&) {
    // For each OutputType in OutputTypeList, add tests with fixed InputType
    (addOneTestAllChannels@FUNDAMENTAL_TYPE@<InputType, fk::TypeAt_t<Idx, OutputTypeList>>(), ...);
}

#define START_ADDING_TESTS@FUNDAMENTAL_TYPE@ void addTests@FUNDAMENTAL_TYPE@() {
#define STOP_ADDING_TESTS@FUNDAMENTAL_TYPE@ }

#define RUN_ALL_TESTS@FUNDAMENTAL_TYPE@ \
addTests@FUNDAMENTAL_TYPE@(); \
bool correct{true}; \
for (const auto& [testName, testFunc] : testCases) { \
    if (!testFunc()) { \
        correct = false; \
    } \
} \
testCases.clear(); \
return correct ? 0 : -1; 
#ifdef WIN32
int UTEST_SATURATE_@FUNDAMENTAL_TYPE_UPPER@_EXPORT launch@FUNDAMENTAL_TYPE@();
#else
int  EXPORT_FN_@FUNDAMENTAL_TYPE_UPPER@  launch@FUNDAMENTAL_TYPE@();
#endif